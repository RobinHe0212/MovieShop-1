# 04 Creating Database with Entity Framework Core

## Installing Entity Framework Core and exploring different approaches

### Introduction to Entity Framework Core

Entity Framework Core or EF Core is designed as object-relational mapper (O/RM) which is open source library from Microsoft that helps developers in accessing the databases. The main idea behind EF Core is to reduce the time drastically that developers spend on writing regular data-access code. Typically when we are working on a project like the one we are working right now, as developers it would be beneficiary if we can spend most of our time in writing business logic, UI etc rather than writing data-access logic. This is where ORM comes in to picture which acts like a bridge between our database and our .NET objects thus eliminating need for most of the data-access code.  

As I said EF Core is an ORM that maps between database and .NET

| Database                                    | .NET                                                                     |
| ------------------------------------------- | ------------------------------------------------------------------------ |
| Table                                       | .NET Class                                                               |
| Columns                                     | Typically class properties                                               |
| Rows/Records                                | Usually instance of IList or ICollection etc                             |
| Primary Key                                 | An instance of class which is unique                                     |
| Foreign Key                                 | Reference to another class as property                                   |
| SQL where, offset, fetch next, group by etc | .NET Linq methods (on IQueryable) such as Where, Skip, Take, GroupBy etc |

Even though there are lots of good things about EF Core and generally O/RM's there are certainly some downsides that you need to keep in mind when you are working with it. You can think of EF as a tool that helps developers save lots of time, but at the end of the day its just a tool that will work well only if you know how to use it properly. One of the issues with EF is lots of "magic" that happens behind the scenes that sometimes blindsides developers. With EF You can technically create entire database, manage CRUD operations without writing single line of SQL query. The one pain point where lots of developers encounter with EF is it seems like it is working great in Development environment but performs poorly in real world tests where we have huge amount of data and users accessing the application.Its especially important in these scenarios to see what kinda SQL queries are being generated by EF and whether those queries are high performing ones or not. We will look into some of the optimizing techniques later on too improve the performance of EF Core.

#### Installing Entity Framework Core

There are multiple ways you can install EF Core, we will look at two ways

#### Visual Studio NuGet Package Manager Dialog

* Right Click on MovieShop.Data and select Manage NuGet Packages
* Click on the Browse
* Search for Microsoft.EntityFrameworkCore.SqlServer and click Install

#### Visual Studio NuGet Package Manager Console

* From the Visual Studio menu, select Tools > NuGet Package Manager > Package Manager Console
* Make sure for Default project select MovieShop.Data project
* To install the SQL Server provider, run the following command in the Package Manager Console:
  * Install-Package Microsoft.EntityFrameworkCore.SqlServer

>*There is one more thing we need to do to work with EF, that is to install Entity Framework Core tools which helps us in do things like creating and applying database migrations, or creating an EF Core model based on an existing database.*

#### Get the Package Manager Console tools

Install-Package Microsoft.EntityFrameworkCore.Tools
Install-Package Microsoft.EntityFrameworkCore.Design

## Understanding ER-diagram of the Database that is being built

First, lets examine the database and its tables that we are going to build.

**Movie Shop Database ER diagram**
 ![alt text](images/03.01&#32;ER&#32;diagram.png "Movie Shop Database ER diagram")

 If you loos at the ER diagram its fairly self-explanatory. Let's take a look at each table and their relationships in more details

 * __Genre__ : Its a simple table with Id as Primary Key and Name column which indicates Genre name. In our application there are around 20 Genres. The Genre table data is not going to change very often.
 * __Movie__: Movie table has typical columns that are associated with a Movie entity. There are couple of columns that we point to external Url, i.e ImdbUrl and TmdbId which are links to that movie specific pages on Imdb and Tmdb websites. The PosterUrl and BackdropUrl point to the images online which are from Tmdb API.
 * __MovieGenres__ : In our application any movie can belong to one or more Genre and any Genre can have one or more Movies. So we have a junction table called MovieGenres that has Primary Keys from Movie and Genre tables respectively.
 * __Casts__: Casts table represents all the casts with one cast in zero or more movies.
 * __MovieCasts__: Each Movie has more than one cast and one cast can be in zero or more movies. MovieCasts is junction table for Movies and Casts with Character being the name of that cast in that particular movie.
 * __Crew__: Crew table is similar to Casts in that it has all the Crew member for our movies.
 * __MovieCrew__: MovieCrew is junction table just like MovieCats where we have one Crew that belongs to zero or more movies and one movie having zero or more Crew members.
 * __Users__ : Users table represents the data for each user for the application that include normal Customer that can browse our application and purchase movies and Admin users that can change the Data in Database.
 * __Roles__: Simple Roles table that represents all the roles a User of the application can have. 
 * __UserRoles__: Each user in our application can have one or more Roles and one Role can belong to one or more User. UserRoles table is the junction table that has RoleId and UserId
 * __Purchases__: Purchases table holds the information about Movie Purchases done by the Users of the application. One User can purchase one or more movies, but he can only purchase one movie ony once.
 * __Reviews__: Users of the application can review each movie by giving it a Rating on a scale of 1 to 1 and also add some Review Text.
 * __Favorites__: Users can also add many movies as their favorites so that they can be easily accessible on the application for them to purchase them later or review them easily.

 So, in total we have 13 tables for our application. WE are going to fill those tables with data later once we create our Database using Entity Framework Core Code-First approach.
 Code-First approach is where we create Data Models entity classes and then we will be using something called Entity Framework __Migrations__ to create our Database.

 ## Creating the Database using Entity Framework Code-First approach.

 ### Creating our MovieShop DbContext.
    
The most important class in Entity Framework is DbContext. So for us to create database or query database we need to create our application's DbContext whcih we will be calling as __MovieShopDbContext__ that will derive from EF's DbContext. Let's create new class as shown below in MovieShop.Data project.

```csharp

namespace MovieShop.Data
{
   public class MovieShopDbContext: DbContext
    {
        public MovieShopDbContext(DbContextOptions<MovieShopDbContext> options):base(options)
        {

        }
    }
}
```

Our MovieShopDbContext has constructor with __DbContextOptions__ as DbContext must have an instance of DbContextOptions in order to perform any work. We can configure our Database provider such as SQL Server provider, conectionString etc with DbContextOptions. But since we are using ASP.NEt Core we are going to use it's buil-in Dependency Injection and Configure those in our Startup.cs

First let's add connectionString for our application in appsettings.json file

```json
 {
  "ConnectionStrings": {
    "MovieShopDbConnection": "Server=(local);Integrated Security=true;Initial Catalog=MovieShopDb;"
  },

  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "AllowedHosts": "*"
}

```

Next we need to register our MovieShopDbContext in ASP.NET Core Services, Also add necessary using statements. 

```csharp
using Microsoft.EntityFrameworkCore;
using MovieShop.Data;

public void ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext<MovieShopDbContext>(options =>
                options.UseSqlServer(Configuration.GetConnectionString("MovieShopDbConnection")));

            services.AddCors(options =>
            {
                options.AddPolicy(_myAllowSpecificOrigins,
                                  builder =>
                                  {
                                      builder.WithOrigins("http://localhost:4200").AllowAnyHeader().AllowAnyMethod();
                                  });
            });
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }
```

Now lets create our first Model, which should be simple, Add new class as shown below in Entities Project

```csharp
namespace MovieShop.Entities
{
    public class Genre
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
}

```
Now that we have created a model we need to tell our __MovieShopDbContext__ that we are going to create Genre table. Typically a table in our database is represented as a property of __DbSet__ type in our DbContext. Entity Framework uses a set of conventions to build a model based on the shape of your entity classes. For example in our case Genre Entity has __Id__ property which EF Core will assumes that the database will use the SQL IDENTITY command to create a unique key when a new row is added. Also we have <ClassName>Id, which will also work as primary for EF.

In Entity Framework we can use something called Fluent API or conventions and data annotations to configure our model so that we build our database tables as per requirement. For example we can have Maximum length for Name column, we can have not null for Name column, create indexes, specify foreign key relationships etc and much more.

For example if you want Name of Genre to be not null and have a maximum length of 64 then with DataAnnotations we can specify them as shown below

```csharp

    public class Genre
    {
        public int Id { get; set; }

        [Required]
        [MaxLength(64)]
        public string Name { get; set; }
    }

```

But in our Project we are going to use Fluent API as we wanna keep our Entities very clean and not cluttered with Attributes. WE want them to be plain classes. Fluent API is much more powerful way of configuring our entities without modifying our entity classes and at the same time Fluent API configuration has the highest precedence and will override conventions and data annotations.


Lets add DbSet<Genre> as property of our MovieShopDbContext and we override OnModelCreating method to create our Fluent API configurations. OnModelCreating method takes ModelBuilder object which is THE class that we use to define our model.The ModelBuilder class has Entity<T> method which we are going to use to describe our Entity. The Entity<T> method returns the EntityTypeBuilder<T> object which has numerous methods that we can use to describe our model to Entity Framework. 

```csharp
namespace MovieShop.Data
{
   public class MovieShopDbContext: DbContext
    {
        public MovieShopDbContext(DbContextOptions<MovieShopDbContext> options):base(options)
        {

        }

        public DbSet<Genre> Genres { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Genre>(ConfigureGenre);
        }

        private void ConfigureGenre(EntityTypeBuilder<Genre> builder)
        {
            // ToTable(table) method is used to define the Table name for Entity Class, in this case we are creating Genre table. Equivalent to the Table attribute
            builder.ToTable("Genre");

            // HasKey(selector) method takes lambda expression that selcts the primary key for our Table, in our case we want Id as primary Key. It is similar to [Key] attribute in dataannotations.
            builder.HasKey(g => g.Id);

            // Property(selector) is used to describe more details about property or column in our table, like making it not null or restricting the maximum length etc and many more.
            builder.Property(g => g.Name).IsRequired().HasMaxLength(64);
        }
    }
}

```

#### Migrations

The migrations feature in EF Core provides a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database
Next open Visual Studio Package Manager Console and add make sure you are in MovieShop.Data Project and add following command

```cmd
  Add-Migration InitialMigration

```
The migration name can be used like a commit message in a version control system. It should be meaningful.

Three files are added to your project under the Migrations directory in MovieShop.Data Project

  * XXXXXXXXXXXXXX_InitialMigration.cs--The main migrations file. Contains the operations necessary to apply the migration (in Up()) and to revert it (in Down()).
  * XXXXXXXXXXXXX_InitialMigration.Designer.cs--The migrations metadata file. Contains information used by EF
  * MovieShopDbContextModelSnapshot.cs -- A snapshot of your current model. Used to determine what changed when adding the next migration.

Next strp is to update the Database which will apply the created migration to create the database.

```cmd

Update-Database

```
Here is our Database with first Table __Genre__. EF also creates a table called __EFMigrationHistory__ which will hold all the migration information. Migrations history table is a table used by Code First Migrations to store details about migrations applied to the database. It is created when applying the first migration to the database

> ![alt text](images/04.01&#32;First&#32;Migration&#32;Updated.png "First Migration Database")

Now, we wanna create our Movie entity with followinf properties

```csharp
  public class Movie
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Overview { get; set; }
        public string Tagline { get; set; }
        public decimal? Budget { get; set; }
        public decimal? Revenue { get; set; }
        public string ImdbUrl { get; set; }
        public string TmdbUrl { get; set; }
        public string PosterUrl { get; set; }
        public string BackdropUrl { get; set; }
        public string OriginalLanguage { get; set; }
        public DateTime? ReleaseDate { get; set; }
        public int? RunTime { get; set; }
        public decimal? Price { get; set; }
     }
```

We need to Configure Fluent API for our Movie Entity. First lets add  Movies DbSet ptoperty, then add Fuent API Configuration.
Add Following Code in __MovieShopDbContext__
```csharp

        public DbSet<Movie> Movies { get; set; }

       protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Genre>(ConfigureGenre);
            modelBuilder.Entity<Movie>(ConfigureMovie);
        }

       private void ConfigureMovie(EntityTypeBuilder<Movie> builder) 
        {
            builder.ToTable("Movie");
            builder.HasKey(m => m.Id);
            builder.HasIndex(m => m.Title);
            builder.Property(m => m.Title).IsRequired().HasMaxLength(256);
            builder.Property(m => m.Overview).HasMaxLength(4096);
            builder.Property(m => m.Tagline).HasMaxLength(512);
            builder.Property(m => m.ImdbUrl).HasMaxLength(2084);
            builder.Property(m => m.TmdbUrl).HasMaxLength(2084);
            builder.Property(m => m.PosterUrl).HasMaxLength(2084);
            builder.Property(m => m.BackdropUrl).HasMaxLength(2084);
            builder.Property(m => m.OriginalLanguage).HasMaxLength(64);
            builder.Property(m => m.Price).HasColumnType("decimal(5, 2)");
        }

```
Now we will add migration for creating Movie Table.

```cmd
add-migration MovieTable
update-database
```

Next tables we are going to create are Cast and Crew whic are pretty straight forwards and self explanotary.

Here are Cast and Crew entities.

```csharp

   public class Cast
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }
        public string TmdbUrl { get; set; }
        public string ProfilePath { get; set; }
    }

  public class Crew
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }
        public string TmdbUrl { get; set; }
        public string ProfilePath { get; set; }
    }

```

```csharp

        public DbSet<Crew> Crews { get; set; }
        public DbSet<Cast> Casts { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Genre>(ConfigureGenre);
            modelBuilder.Entity<Movie>(ConfigureMovie);
            modelBuilder.Entity<Cast>(ConfigureCast);
            modelBuilder.Entity<Crew>(ConfigureCrew);
        }

        private void ConfigureCrew(EntityTypeBuilder<Crew> builder)
        {
            builder.ToTable("Crew");
            builder.HasKey(c => c.Id);
            builder.HasIndex(c => c.Name);
            builder.Property(c => c.Name).HasMaxLength(128);
            builder.Property(c => c.ProfilePath).HasMaxLength(2084);
        }

        private void ConfigureCast(EntityTypeBuilder<Cast> builder)
        {
            builder.ToTable("Cast");
            builder.HasKey(c => c.Id);
            builder.HasIndex(c => c.Name);
            builder.Property(c => c.Name).HasMaxLength(128);
            builder.Property(c => c.ProfilePath).HasMaxLength(2084);
        }
```

Finally, add migrations

```cmd
add-migration CastCrewTable
update-database
```

Our next entities/tables that we are going to create are User and Role tables.

```csharp

  public class User
    {
        public int Id { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime? DateOfBirth { get; set; }
        public string Email { get; set; }
        public string HashedPassword { get; set; }
        public string Salt { get; set; }
        public string PhoneNumber { get; set; }
        public bool TwoFactorEnabled { get; set; }
        public DateTime? LockoutEndDate { get; set; }
        public DateTime? LastLoginDateTime { get; set; }
        public bool IsLocked { get; set; }
        public int AccessFailedCount { get; set; }
    }

    public class Role
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
```

```csharp

        public DbSet<User> Users { get; set; }
        public DbSet<Role> Roles { get; set; }


        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Genre>(ConfigureGenre);
            modelBuilder.Entity<Movie>(ConfigureMovie);
            modelBuilder.Entity<Cast>(ConfigureCast);
            modelBuilder.Entity<Crew>(ConfigureCrew);
            modelBuilder.Entity<User>(ConfigureUser);
            modelBuilder.Entity<Role>(ConfigureRole);
        }

       private void ConfigureRole(EntityTypeBuilder<Role> builder)
        {
            builder.ToTable("Role");
            builder.HasKey(r => r.Id);
            builder.Property(r => r.Name).HasMaxLength(20);
        }

        private void ConfigureUser(EntityTypeBuilder<User> builder)
        {
            builder.ToTable("User");
            builder.HasKey(u => u.Id);
            builder.HasIndex(u => u.Email).IsUnique();
            builder.Property(u => u.Email).HasMaxLength(256);
            builder.Property(u => u.FirstName).HasMaxLength(128);
            builder.Property(u => u.LastName).HasMaxLength(128);
            builder.Property(u => u.HashedPassword).HasMaxLength(1024);
            builder.Property(u => u.PhoneNumber).HasMaxLength(16);
            builder.Property(u => u.Salt).HasMaxLength(1024);
            builder.Property(u => u.IsLocked).HasDefaultValue(false);
        }
```

```cmd
add-migration UserandRoleTable
update-database
```